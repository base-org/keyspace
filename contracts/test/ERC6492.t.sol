// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.27;

import {Test, Vm, console} from "forge-std/Test.sol";

import {SignatureCheckerLib} from "solady/utils/SignatureCheckerLib.sol";

import {Keystore} from "../src/Keystore.sol";
import {ConfigLib} from "../src/KeystoreLibs.sol";

import {MultiOwnableWallet} from "../src/examples/MultiOwnableWallet.opstack.sol";
import {MultiOwnableWalletFactory} from "../src/examples/MultiOwnableWalletFactory.opstack.sol";

interface IMulticall3 {
    struct Call3 {
        // Target contract to call.
        address target;
        // If false, the entire call will revert if the call fails.
        bool allowFailure;
        // Data to call on the target contract.
        bytes callData;
    }

    struct Result {
        // True if the call succeeded, false otherwise.
        bool success;
        // Return data if the call succeeded, or revert data if the call reverted.
        bytes returnData;
    }

    /// @notice Aggregate calls, ensuring each returns success if required
    /// @param calls An array of Call3 structs
    /// @return returnData An array of Result structs
    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);
}

contract EIP6492Test is Test {
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    //                                           CONSTANTS                                            //
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    address constant MULTICALL_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;
    bytes32 constant MAGIC_BYTES = 0x6492649264926492649264926492649264926492649264926492649264926492;

    MultiOwnableWallet impl;
    MultiOwnableWalletFactory factory;
    IMulticall3 multicall3;

    mapping(string walletLabel => Vm.Wallet) _wallets;

    address[] _currentSigners;
    IMulticall3.Call3[] _calls;

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    //                                             SETUP                                              //
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    function setUp() public {
        // Deploy the account implementation and factory.
        impl = new MultiOwnableWallet({masterChainId: 1});
        factory = new MultiOwnableWalletFactory({implementation_: address(impl)});

        // Create some wallets to play with.
        _wallets["alice"] = vm.createWallet("alice");
        _wallets["bob"] = vm.createWallet("bob");
        _wallets["charles"] = vm.createWallet("charles");

        // Fork Base Sepolia and set the Multicall contract.
        Chain memory chain = getChain("base_sepolia");
        vm.createSelectFork(chain.rpcUrl);
        multicall3 = IMulticall3(MULTICALL_ADDRESS);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    //                                        TEST FUNCTIONS                                          //
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    /// @notice Verifies an ERC-6492 signature of `hash` for a wallet that has not been deployed.
    function test_WalletNotDeployed(bytes32 hash) public {
        // Setup test:
        //  1. Push a Call3 to MultiOwnableWalletFactory.createAccount()
        //  2. Push a Call3 to Keystore.setConfig() to add Bob
        address account;
        {
            // Create the initial config with Alice as the only signer.
            _currentSigners.push(_wallets["alice"].addr);
            ConfigLib.Config memory config =
                ConfigLib.Config({nonce: 0, data: abi.encode(address(impl), _currentSigners)});

            // Compute the counterfactual account address.
            account = factory.getAddress({config: config, salt: 0});

            // Push a `Call3` call to deploy the account.
            _pushCall3({
                target: address(factory),
                callData: abi.encodeCall(MultiOwnableWalletFactory.createAccount, (config, 0))
            });

            // Push a `Call3` call to add Bob as a signer, signed by Alice.
            _pushAddSignerCall3({account: account, authorizer: "alice", addedSigner: "bob", configNonce: 1});
        }

        // Test that an ERC-6492 signature generated by Bob correctly verifies.
        assertTrue(
            SignatureCheckerLib.isValidERC6492SignatureNow({
                signer: account,
                hash: hash,
                signature: _build6492Signature({account: account, hash: hash, signer: "bob"})
            })
        );
    }

    /// @notice Verifies an ERC-6492 signature of `hash` for an already deployed wallet that has a stale Keystore
    ///         config.
    function test_WalletDeployedButStaleConfig(bytes32 hash) public {
        // Setup test:
        //  1. Deploy the account.
        //  2. Push a Call3 to Keystore.setConfig() to add Bob
        //  3. Push a Call3 to Keystore.setConfig() to add Charles
        address account;
        {
            // Create the initial config with Alice as the only signer.
            _currentSigners.push(_wallets["alice"].addr);
            ConfigLib.Config memory config =
                ConfigLib.Config({nonce: 0, data: abi.encode(address(impl), _currentSigners)});

            // Deploy the account.
            account = address(factory.createAccount({config: config, salt: 0}));

            // Push a `Call3` call to add Bob as a signer, signed by Alice.
            _pushAddSignerCall3({account: account, authorizer: "alice", addedSigner: "bob", configNonce: 1});

            // Push a `Call3` call to add Charles as a signer, signed by Bob.
            _pushAddSignerCall3({account: account, authorizer: "bob", addedSigner: "charles", configNonce: 2});
        }

        // Test that an ERC-6492 signature generated by Charles correctly verifies.
        assertTrue(
            SignatureCheckerLib.isValidERC6492SignatureNow({
                signer: account,
                hash: hash,
                signature: _build6492Signature({account: account, hash: hash, signer: "charles"})
            })
        );
    }

    /// @notice Verifies an ERC-6492 signature of `hash` for a wallet that is deployed and has the latest Keystore
    ///         config.
    function test_WalletDeployedAndUpToDateConfig(bytes32 hash) public {
        // Setup test:
        //  1. Deploy the account.
        //  2. Call Keystore.setConfig() to add Bob
        //  3. Call Keystore.setConfig() to add Charles
        address account;
        {
            // Create the initial config with Alice as the only signer.
            _currentSigners.push(_wallets["alice"].addr);
            ConfigLib.Config memory config =
                ConfigLib.Config({nonce: 0, data: abi.encode(address(impl), _currentSigners)});

            // Deploy the account.
            MultiOwnableWallet account_ = factory.createAccount({config: config, salt: 0});
            account = address(account_);

            // Add Bob as a signer, signed by Alice.
            bytes memory authorizeAndValidateProof;
            (config, authorizeAndValidateProof) =
                _addSignerPayload({account: account, authorizer: "alice", addedSigner: "bob", configNonce: 1});
            account_.setConfig({newConfig: config, authorizeAndValidateProof: authorizeAndValidateProof});

            // Add Charles as a signer, signed by Bob.
            (config, authorizeAndValidateProof) =
                _addSignerPayload({account: account, authorizer: "bob", addedSigner: "charles", configNonce: 2});
            account_.setConfig({newConfig: config, authorizeAndValidateProof: authorizeAndValidateProof});
        }

        // Test that an ERC-6492 signature generated by Charles correctly verifies.
        assertTrue(
            SignatureCheckerLib.isValidERC6492SignatureNow({
                signer: address(account),
                hash: hash,
                signature: _build6492Signature({account: address(account), hash: hash, signer: "charles"})
            })
        );
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    //                                        PRIVATE FUNCTIONS                                       //
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    /// @dev Computes the hash of a Keystore config.
    ///
    /// @param config The Keystore config to hash.
    /// @param account The address of the account associated with the Keystore config.
    ///
    /// @return The Keystore config hash.
    function _hashConfig(ConfigLib.Config memory config, address account) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(account, config.nonce, config.data));
    }

    /// @dev Generates an EOA signature for a given hash.
    ///
    /// @param wallet The wallet to sign the hash.
    /// @param hash The hash to be signed.
    ///
    /// @return The generated signature encode as `abi.encodePacked(r, s, v)`.
    function _eoaSignature(Vm.Wallet memory wallet, bytes32 hash) private returns (bytes memory) {
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(wallet, hash);
        return abi.encodePacked(r, s, v);
    }

    /// @dev Generates a authorization & validation proof for adding a new signer.
    ///
    /// @param configHash The hash of the Keystore config.
    /// @param authorizer The wallet label of the authorizer.
    /// @param addedSigner The wallet label of the signer to add.
    ///
    /// @return The generated proof.
    function _generateProof(bytes32 configHash, string memory authorizer, string memory addedSigner)
        private
        returns (bytes memory)
    {
        bytes memory signatureAuth =
            abi.encode(_wallets[authorizer].addr, _eoaSignature({wallet: _wallets[authorizer], hash: configHash}));
        bytes memory signatureUpdate =
            abi.encode(_currentSigners.length - 1, _eoaSignature({wallet: _wallets[addedSigner], hash: configHash}));
        return abi.encode(signatureAuth, signatureUpdate);
    }

    /// @dev Adds a signer to the payload for Keystore config updates.
    ///
    /// @param account The account address.
    /// @param authorizer The wallet label of the authorizer.
    /// @param addedSigner The wallet label of the signer to add.
    /// @param configNonce The nonce of the Keystore config.
    ///
    /// @return config The updated Keystore config.
    /// @return authorizeAndValidateProof The proof for authorization and validation.
    function _addSignerPayload(
        address account,
        string memory authorizer,
        string memory addedSigner,
        uint256 configNonce
    ) private returns (ConfigLib.Config memory config, bytes memory authorizeAndValidateProof) {
        _currentSigners.push(_wallets[addedSigner].addr);

        config = ConfigLib.Config({nonce: configNonce, data: abi.encode(address(impl), _currentSigners)});

        authorizeAndValidateProof = _generateProof({
            configHash: _hashConfig({config: config, account: account}),
            authorizer: authorizer,
            addedSigner: addedSigner
        });
    }

    /// @dev Pushes a Call3 to the `_calls` array for adding a signer.
    ///
    /// @param account The account address.
    /// @param authorizer The wallet label of the authorizer.
    /// @param addedSigner The wallet label of the signer to be added.
    /// @param configNonce The nonce of the Keystore config.
    function _pushAddSignerCall3(
        address account,
        string memory authorizer,
        string memory addedSigner,
        uint256 configNonce
    ) private {
        (ConfigLib.Config memory config, bytes memory authorizeAndValidateProof) = _addSignerPayload({
            account: account,
            authorizer: authorizer,
            addedSigner: addedSigner,
            configNonce: configNonce
        });

        _pushCall3({target: account, callData: abi.encodeCall(Keystore.setConfig, (config, authorizeAndValidateProof))});
    }

    /// @dev Pushes a Call3 to the `_calls` array.
    ///
    /// @param target The target address.
    /// @param callData The call data to execute.
    function _pushCall3(address target, bytes memory callData) private {
        _calls.push(IMulticall3.Call3({target: target, allowFailure: false, callData: callData}));
    }

    /// @dev Builds an ERC-6492 signature.
    ///
    /// @param account The account address.
    /// @param hash The hash to be signed.
    /// @param signer The wallet label of the signer.
    ///
    /// @return The generated signature.
    function _build6492Signature(address account, bytes32 hash, string memory signer) private returns (bytes memory) {
        // Build and sign a replay safe hash with Bob.
        bytes32 replaySafeHash = impl.replaySafeHash({account: account, hash: hash});
        bytes memory signature =
            abi.encode(_wallets[signer].addr, _eoaSignature({wallet: _wallets[signer], hash: replaySafeHash}));

        // Wrap the signatyre in a 6492 format.
        return bytes.concat(
            abi.encode(MULTICALL_ADDRESS, abi.encodeCall(IMulticall3.aggregate3, (_calls)), signature), MAGIC_BYTES
        );
    }
}
